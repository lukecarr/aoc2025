// Test utilities copied form day1part1.d.ts
type Equal<A, B> = [A] extends [B] ? ([B] extends [A] ? true : false) : false;
type Assert<T extends true> = T;

// Type for building integer literals, copied from day1part1.d.ts
type Digit = {
  '0': [];
  '1': [0];
  '2': [0,0];
  '3': [0,0,0];
  '4': [0,0,0,0];
  '5': [0,0,0,0,0];
  '6': [0,0,0,0,0,0];
  '7': [0,0,0,0,0,0,0];
  '8': [0,0,0,0,0,0,0,0];
  '9': [0,0,0,0,0,0,0,0,0];
};

// Constant representing 100.
type N100<T extends any[] = []> = T['length'] extends 100 ? T : N100<[...T, 0]>;

// Arithmetic operations for add and subtract
type Add<A extends any[], B extends any[]> = [...A, ...B];
type Sub<A extends any[], B extends any[]> = A extends [...B, ...infer R] ? R : never;

// Mod100 returns the result of T mod 100.
type Mod100<T extends any[]> = T extends [...N100, ...infer Rest] ? Mod100<Rest> : T;

// Div100 returns the quotient of T / 100.
type Div100<T extends any[], Acc extends any[] = []> = 
  T extends [...N100, ...infer Rest] 
    ? Div100<Rest, [...Acc, 0]> 
    : Acc;

// Mul10 multiplies T by 10.
type Mul10<T extends any[]> = [...T, ...T, ...T, ...T, ...T, ...T, ...T, ...T, ...T, ...T];

// To handle large input numbers (e.g., R1000), I'm going to parse the numbers from the input
// lines as (quotient, remainder) pairs, after dividing by 100 (the dial size). This avoids
// creating tuples with lengths in the thousands, and allows my solution to still calculate the
// correct number of times the dial crosses zero.
type Int = { q: any[], r: any[] };

// ParseInt takes a string as an input and recursively converts it to an integer represented
// as a (quotient, remainder) pair after dividing by 100. 100 is the dial size of the problem,
// so we can safely divide by this and not loose any information that impacts the answer to
// the problem (e.g., R1000 is the same as {q: 10, r: 0}, with q=10 telling us that there are
// 10 full rotations of the dial).
type ParseInt<S extends string, AccQ extends any[] = [], AccR extends any[] = []> = 
  S extends `${infer D extends keyof Digit}${infer Rest}`
    ? ParseInt<
        Rest,
        // New Quotient = (OldQuotient * 10) + (NewRemainder / 100)
        Add<Mul10<AccQ>, Div100<Add<Mul10<AccR>, Digit[D]>>>, 
        // New Remainder = (NewRemainder % 100)
        Mod100<Add<Mul10<AccR>, Digit[D]>>
      >
    : { q: AccQ, r: AccR };

type TestParseInt = Assert<Equal<ParseInt<'209'>, { q: Digit['2'], r: Digit['9'] }>>;

// CalcHitsR takes an Int (quotient, remainder) and returns the number of times (hits) this
// will move the dial position over zero, given the current Pos.
// We just add the Int's quotient (which is divided by 100 in ParseInt, so a full rotation),
// and also add one more if the current Pos + the Int's remainder exceeds 100.
type CalcHitsR<Pos extends any[], Num extends Int> = 
  Add<Num['q'], Div100<Add<Pos, Num['r']>>>;

// CalcHitsL performs the same function as CalcHitsR, but for left rotations of the dial.
// The logic is tweaked to consider that when the dial moves left, the position wraps back around
// to 99 after 0.
type CalcHitsL<Pos extends any[], Num extends Int> = 
  Add<
    Num['q'], 
    Pos['length'] extends 0 // If the current Pos is zero
      ? [] // the remainder (which is 0 <= n <= 99) will never result in a full dial rotation
      : Num['r'] extends [...Pos, ...any[]] ? Digit['1'] : [] // otherwise add one to the hits if remainder >= current
  >;

// ProcessStep, similar to part 1, identifies if a line in the problem input starts with an 'L' or 'R', and
// passes to CalcHitsL or CalcHitsR respectively.
type ProcessStep<Line extends string, Pos extends any[]> = 
  Line extends `L${infer Val}` ? CalcHitsL<Pos, ParseInt<Val>> :
  Line extends `R${infer Val}` ? CalcHitsR<Pos, ParseInt<Val>> :
  [];

// Whereas CalcHitsL (and ...R) calculate the number of "hits", UpdatePos will take a line as input and calculate
// wher the new dial position is after the line's instruction is applied to the current Pos.
type UpdatePos<Line extends string, Pos extends any[]> = 
  Line extends `L${infer Val}` ? 
    Mod100<
      ParseInt<Val>['r'] extends [...Pos, ...infer Rem] 
      ? Sub<N100, Rem> 
      : Sub<Pos, ParseInt<Val>['r']>
    > :
  Line extends `R${infer Val}` ? Mod100<Add<Pos, ParseInt<Val>['r']>> :
  Pos;

// Similarly to part 1, we process in hardcoded blocks of 10 to avoid putting stress on the TS type compiler.
// For each line:
// 1. Calculate the Hits generated by the move.
// 2. Add Hits to Password.
// 3. Update Position.
// 4. Pass new Position to next line.
type ProcessBlock<Block extends string, Pos extends any[], Password extends any[]> = 
  Block extends `${infer L1}\n${infer L2}\n${infer L3}\n${infer L4}\n${infer L5}\n${infer L6}\n${infer L7}\n${infer L8}\n${infer L9}\n${infer L10}` ?
  
  // Line 1
  ProcessStep<L1, Pos> extends infer H1 extends any[] ?
  UpdatePos<L1, Pos>   extends infer P1 extends any[] ?
  
  // Line 2
  ProcessStep<L2, P1> extends infer H2 extends any[] ?
  UpdatePos<L2, P1>   extends infer P2 extends any[] ?

  // Line 3
  ProcessStep<L3, P2> extends infer H3 extends any[] ?
  UpdatePos<L3, P2>   extends infer P3 extends any[] ?

  // Line 4
  ProcessStep<L4, P3> extends infer H4 extends any[] ?
  UpdatePos<L4, P3>   extends infer P4 extends any[] ?

  // Line 5
  ProcessStep<L5, P4> extends infer H5 extends any[] ?
  UpdatePos<L5, P4>   extends infer P5 extends any[] ?

  // Line 6
  ProcessStep<L6, P5> extends infer H6 extends any[] ?
  UpdatePos<L6, P5>   extends infer P6 extends any[] ?

  // Line 7
  ProcessStep<L7, P6> extends infer H7 extends any[] ?
  UpdatePos<L7, P6>   extends infer P7 extends any[] ?

  // Line 8
  ProcessStep<L8, P7> extends infer H8 extends any[] ?
  UpdatePos<L8, P7>   extends infer P8 extends any[] ?

  // Line 9
  ProcessStep<L9, P8> extends infer H9 extends any[] ?
  UpdatePos<L9, P8>   extends infer P9 extends any[] ?

  // Line 10
  ProcessStep<L10, P9> extends infer H10 extends any[] ?
  UpdatePos<L10, P9>   extends infer P10 extends any[] ?

  { 
    // The dial position does not need to be aggregated, it's the last position (P10)
    pos: P10, 
    // Sum up all of the hits, plus the original password passed in
    password: [...Password, 
      ...H1, ...H2, ...H3, ...H4, ...H5, ...H6, ...H7, ...H8, ...H9, ...H10
    ]
  } 
  : never : never : never : never : never : never : never : never : never : never 
  : never : never : never : never : never : never : never : never : never : never : never;

// Processes a single line, updating the position and calculating if the password has been
// incremented by the instruction being applied to the current Pos.
type ProcessSingleLine<Line extends string, Pos extends any[], Password extends any[]> = {
  pos: UpdatePos<Line, Pos>,
  password: [...Password, ...ProcessStep<Line, Pos>]
};

// Similarly to part 1, SolveRec will recursively process the lines of the test input, keeping
// track of the dial position and "password" (number of hits when the dial moves across zero).
// We process in batches of 10 lines at a time to keep the TS type compiler happy.
type SolveRec<Input extends string, Pos extends any[], Password extends any[]> =
  // While the input still has at least ten lines, process ten lines
  Input extends `${infer L1}\n${infer L2}\n${infer L3}\n${infer L4}\n${infer L5}\n${infer L6}\n${infer L7}\n${infer L8}\n${infer L9}\n${infer L10}\n${infer Rest}`
    ? ProcessBlock<`${L1}\n${L2}\n${L3}\n${L4}\n${L5}\n${L6}\n${L7}\n${L8}\n${L9}\n${L10}`, Pos, Password> extends { pos: infer NewPos extends any[], password: infer NewPassword extends any[] }
      ? SolveRec<Rest, NewPos, NewPassword>
      : never
  // Then, when we're down to less than ten lines, process line by line
  : Input extends `${infer Line}\n${infer Rest}`
    ? ProcessSingleLine<Line, Pos, Password> extends { pos: infer NewPos extends any[], password: infer NewPassword extends any[] }
      ? SolveRec<Rest, NewPos, NewPassword>
      : never
  // Finally, process the last line
  : ProcessSingleLine<Input, Pos, Password>['password']['length'];

// Solve will solve the problem, with the starting position set to 50 as per the puzzle spec.
type Solve<Input extends string> = SolveRec<Input, ParseInt<'50'>['r'], []>;

type Input = `L68
L30
R48
L5
R60
L55
L1
L99
R14
L82`; 

type Result = Solve<Input>;
